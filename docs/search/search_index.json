{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyGnome: Python Library for Genome Annotations","text":"<p>PyGnome is a Python library for working with genomic annotations and sequences. It provides efficient data structures and parsers for common genomic file formats, making it easy to work with genomic data in Python. </p> <p>At its core, PyGnome offers \"Genomic feature stores\", which are specialized data structures for efficient storage, indexing, and querying of genomic features based on their coordinates, solving the fundamental bioinformatics challenge of quickly locating genomic elements within large genomes.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Genomic Feature Models: Comprehensive object models for genes, transcripts, exons, variants, and more</li> <li>Efficient Feature Storage: Multiple implementations for fast genomic feature queries</li> <li>File Format Parsers: Support for FASTA/FASTQ, GFF/GTF, VCF, and MSI formats</li> <li>Sequence Handling: Memory-efficient representations of DNA and RNA sequences</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pygnome\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.genome_loader import GenomeLoader\n\n# Load a genome from GTF and FASTA files\nloader = GenomeLoader(genome_name=\"GRCh38\", species=\"Homo sapiens\")\ngenome = loader.load(\n    gtf_file=Path(\"path/to/annotations.gtf\"),\n    fasta_file=Path(\"path/to/genome.fa.gz\")\n)\n\n# Access genomic features\nfor gene in genome.genes.values():\n    print(f\"Gene: {gene.id} ({gene.name}) - {gene.chrom}:{gene.start}-{gene.end}\")\n\n    for transcript in gene.transcripts:\n        print(f\"  Transcript: {transcript.id} - Exons: {len(transcript.exons)}\")\n</code></pre>"},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#parsing-fasta-files","title":"Parsing FASTA Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.fasta.fasta_parser import FastaParser\n\n# Parse a FASTA file\nparser = FastaParser(Path(\"path/to/sequences.fa\"))\nrecords = parser.load()\n\n# Access sequences\nfor record in records:\n    print(f\"Sequence: {record.identifier}\")\n    print(f\"Length: {len(record.sequence)}\")\n\n    # Convert to string if needed\n    seq_str = str(record.sequence)\n    print(f\"First 10 bases: {seq_str[:10]}\")\n\n# Load as dictionary for quick access by identifier\nsequences = FastaParser(Path(\"path/to/sequences.fa\")).load_as_dict()\nmy_seq = sequences[\"chr1\"].sequence\n</code></pre>"},{"location":"#parsing-gffgtf-files","title":"Parsing GFF/GTF Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.gff.gff3_parser import Gff3Parser\nfrom pygnome.parsers.gff.gtf_parser import GtfParser\n\n# Parse a GFF3 file\ngff_parser = Gff3Parser(Path(\"path/to/annotations.gff3\"))\nfor record in gff_parser:\n    print(f\"{record.type}: {record.chrom}:{record.start}-{record.end}\")\n    print(f\"Attributes: {record.attributes}\")\n\n# Parse a GTF file\ngtf_parser = GtfParser(Path(\"path/to/annotations.gtf\"))\nfor record in gtf_parser:\n    if record.type == \"gene\":\n        gene_id = record.attributes.get(\"gene_id\")\n        gene_name = record.attributes.get(\"gene_name\")\n        print(f\"Gene: {gene_id} ({gene_name}) - {record.chrom}:{record.start}-{record.end}\")\n</code></pre>"},{"location":"#parsing-vcf-files","title":"Parsing VCF Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.vcf.vcf_reader import VcfReader\n\n# Open a VCF file\nwith VcfReader(Path(\"path/to/variants.vcf\")) as reader:\n    # Get sample names\n    samples = reader.get_samples()\n    print(f\"Samples: {samples}\")\n\n    # Iterate through records\n    for record in reader:\n        print(f\"Record: {record.get_chrom()}:{record.get_pos()} {record.get_ref()}&gt;{','.join(record.get_alt())}\")\n\n        # Create variant objects from the record using VariantFactory\n        for variant in record:  # Uses VariantFactory internally\n            print(f\"Variant: {variant}\")\n\n        # Access genotypes\n        genotypes = record.get_genotypes()\n        for i, genotype in enumerate(genotypes):\n            print(f\"  {samples[i]}: {genotype}\")\n\n    # Query a specific region\n    for record in reader.fetch(\"chr1\", 1000000, 2000000):\n        for variant in record:\n            print(f\"Region variant: {variant}\")\n</code></pre>"},{"location":"#using-feature-stores","title":"Using Feature Stores","text":"<pre><code>from pygnome.feature_store.genomic_feature_store import GenomicFeatureStore, StoreType\nfrom pygnome.genomics.gene import Gene\nfrom pathlib import Path\n\n# Create a feature store using interval trees (default)\nstore = GenomicFeatureStore()\n\n# Or choose a different implementation\nbinned_store = GenomicFeatureStore(store_type=StoreType.BINNED, bin_size=100000)\nbrute_force_store = GenomicFeatureStore(store_type=StoreType.BRUTE_FORCE)\n\n# Add features to the store\nwith store:  # Use context manager to ensure proper indexing\n    for gene in genome.genes.values():\n        store.add(gene)\n\n        # Add transcripts and other features\n        for transcript in gene.transcripts:\n            store.add(transcript)\n            for exon in transcript.exons:\n                store.add(exon)\n\n# Query features\nfeatures_at_position = store.get_by_position(\"chr1\", 1000000)\nfeatures_in_range = store.get_by_interval(\"chr1\", 1000000, 2000000)\nnearest_feature = store.get_nearest(\"chr1\", 1500000)\n\n# Save and load the store\nstore.save(Path(\"path/to/store.pkl\"))\nloaded_store = GenomicFeatureStore.load(Path(\"path/to/store.pkl\"))\n</code></pre>"},{"location":"#working-with-dnarna-sequences","title":"Working with DNA/RNA Sequences","text":"<pre><code>from pygnome.sequences.dna_string import DnaString\nfrom pygnome.sequences.rna_string import RnaString\n\n# Create a DNA sequence\ndna = DnaString(\"ATGCATGCATGC\")\nprint(f\"Length: {len(dna)}\")\nprint(f\"GC content: {dna.gc_content()}\")\n\n# Get a subsequence\nsubseq = dna[3:9]  # Returns a new DnaString\n\n# Complement and reverse complement\ncomp = dna.complement()\nrev_comp = dna.reverse_complement()\n\n# Transcribe DNA to RNA\nrna = dna.transcribe()  # Returns an RnaString\n\n# Create an RNA sequence\nrna = RnaString(\"AUGCAUGCAUGC\")\n\n# Translate RNA to protein\nprotein = rna.translate()\nprint(f\"Protein: {protein}\")\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#loading-a-complete-genome","title":"Loading a Complete Genome","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.genome_loader import GenomeLoader\n\n# Create a genome loader\nloader = GenomeLoader(\n    genome_name=\"GRCh38\",\n    species=\"Homo sapiens\",\n    verbose=True  # Print progress information\n)\n\n# Load genome structure and sequence\ngenome = loader.load(\n    gtf_file=Path(\"path/to/annotations.gtf\"),\n    fasta_file=Path(\"path/to/genome.fa.gz\")\n)\n\n# Access genome components\nprint(f\"Genome: {genome.name} ({genome.species})\")\nprint(f\"Chromosomes: {len(genome.chromosomes)}\")\nprint(f\"Genes: {len(genome.genes)}\")\n\n# Get a specific chromosome\nchr1 = genome.chromosomes.get(\"chr1\")\nif chr1:\n    print(f\"Chromosome: {chr1.name}, Length: {chr1.length}\")\n    print(f\"Genes on chr1: {len(chr1.genes)}\")\n\n    # Get sequence for a region\n    region_seq = chr1.get_sequence(1000000, 1000100)\n    print(f\"Sequence: {region_seq}\")\n\n# Get a specific gene\ntp53 = genome.genes.get(\"ENSG00000141510\")\nif tp53:\n    print(f\"TP53: {tp53.chrom}:{tp53.start}-{tp53.end} ({tp53.strand})\")\n\n    # Get gene sequence\n    gene_seq = tp53.get_sequence()\n\n    # Get coding sequence\n    for transcript in tp53.transcripts:\n        cds_seq = transcript.get_coding_sequence()\n        protein = transcript.get_protein()\n        print(f\"Transcript {transcript.id}: CDS length: {len(cds_seq)}, Protein length: {len(protein)}\")\n</code></pre>"},{"location":"#working-with-msi-sites","title":"Working with MSI Sites","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.msi.msi_sites_reader import MsiSitesReader\nfrom pygnome.feature_store.genomic_feature_store import GenomicFeatureStore, StoreType\n\n# Parse MSI sites file\nreader = MsiSitesReader(Path(\"path/to/msi_sites.txt\"))\nmsi_sites = reader.read_all()\n\n# Create a specialized MSI store\nmsi_store = GenomicFeatureStore(store_type=StoreType.MSI)\n\n# Add MSI sites to the store\nwith msi_store:\n    for site in msi_sites:\n        msi_store.add(site)\n\n# Query MSI sites\nsites_in_region = msi_store.get_by_interval(\"chr1\", 1000000, 2000000)\nfor site in sites_in_region:\n    print(f\"MSI site: {site.chrom}:{site.start}-{site.end}, Repeat: {site.repeat_unit}\")\n</code></pre>"},{"location":"#performance-considerations","title":"Performance Considerations","text":"<p>PyGnome offers multiple feature store implementations with different performance characteristics:</p> <ul> <li>IntervalTreeStore: Best for random access queries (default)</li> <li>BinnedGenomicStore: Good balance between memory usage and query speed</li> <li>BruteForceFeatureStore: Lowest memory usage but slower queries</li> <li>MsiChromosomeStore: Specialized for MSI sites</li> </ul> <p>For large genomes, consider:</p> <ol> <li>Using the context manager pattern when adding features to ensure proper indexing</li> <li>Calling <code>store.trim()</code> to reduce memory usage before serialization</li> <li>Saving the populated store to disk with <code>store.save()</code> for faster loading in future sessions</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"getting-started/","title":"Getting Started with PyGnome","text":"<p>PyGnome is a Python library for working with genomic annotations and sequences. It provides efficient data structures and parsers for common genomic file formats, making it easy to work with genomic data in Python.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>PyGnome can be installed using pip:</p> <pre><code>pip install pygnome\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Here's a simple example to get you started with PyGnome:</p> <pre><code>from pathlib import Path\nfrom pygnome.parsers.genome_loader import GenomeLoader\n\n# Load a genome from GTF and FASTA files\nloader = GenomeLoader(genome_name=\"GRCh38\", species=\"Homo sapiens\")\ngenome = loader.load(\n    annotation_file=Path(\"path/to/annotations.gtf\"),\n    sequence_file=Path(\"path/to/genome.fa.gz\")\n)\n\n# Access genomic features\nfor gene in genome.genes.values():\n    print(f\"Gene: {gene.id} ({gene.name}) - {gene.chrom}:{gene.start}-{gene.end}\")\n\n    for transcript in gene.transcripts:\n        print(f\"  Transcript: {transcript.id} - Exons: {len(transcript.exons)}\")\n</code></pre>"},{"location":"getting-started/#core-components","title":"Core Components","text":"<p>PyGnome consists of several core components:</p>"},{"location":"getting-started/#genomic-models","title":"Genomic Models","text":"<p>The genomic models provide a comprehensive object-oriented representation of genomic features:</p> <ul> <li><code>Genome</code>: Top-level container for chromosomes and genes</li> <li><code>Chromosome</code>: Contains genes and sequence data</li> <li><code>Gene</code>: Represents a gene with transcripts</li> <li><code>Transcript</code>: Represents a transcript with exons, introns, UTRs, and CDS</li> <li><code>Exon</code>, <code>Intron</code>, <code>UTR</code>, <code>CDS</code>: Represent specific genomic features</li> </ul>"},{"location":"getting-started/#feature-stores","title":"Feature Stores","text":"<p>Feature stores provide efficient storage and retrieval of genomic features:</p> <ul> <li><code>GenomicFeatureStore</code>: Main interface for storing and querying features</li> <li>Multiple implementations with different performance characteristics:</li> <li><code>IntervalTreeStore</code>: Uses interval trees for efficient range queries</li> <li><code>BinnedGenomicStore</code>: Uses binning for memory-efficient storage</li> <li><code>BruteForceFeatureStore</code>: Simple implementation for testing</li> <li><code>MsiChromosomeStore</code>: Specialized for microsatellite instability sites</li> </ul>"},{"location":"getting-started/#sequence-handling","title":"Sequence Handling","text":"<p>PyGnome provides memory-efficient representations of DNA and RNA sequences:</p> <ul> <li><code>DnaString</code>: Memory-efficient 2-bit representation of DNA sequences</li> <li><code>RnaString</code>: RNA sequence representation</li> <li><code>DnaStringArray</code>: Efficient storage for multiple DNA sequences</li> </ul>"},{"location":"getting-started/#parsers","title":"Parsers","text":"<p>PyGnome includes parsers for common genomic file formats:</p> <ul> <li><code>FastaParser</code>: Parses FASTA files</li> <li><code>FastqParser</code>: Parses FASTQ files</li> <li><code>GffParser</code>, <code>Gff3Parser</code>, <code>GtfParser</code>: Parse GFF/GTF annotation files</li> <li><code>VcfReader</code>: Parses VCF variant files</li> <li><code>MsiSitesReader</code>: Parses microsatellite instability sites</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the User Guide for more detailed usage examples</li> <li>Explore the API Reference for detailed documentation of all classes and methods</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed documentation for the PyGnome API. PyGnome is organized into several core modules, each focusing on a specific aspect of genomic data handling.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#genomics","title":"Genomics","text":"<p>The <code>genomics</code> module provides the core data models for representing genomic features:</p> <ul> <li><code>GenomicFeature</code>: Base class for all genomic features</li> <li><code>Genome</code>: Top-level container for chromosomes and genes</li> <li><code>Chromosome</code>: Contains genes and sequence data</li> <li><code>Gene</code>: Represents a gene with transcripts</li> <li><code>Transcript</code>: Represents a transcript with exons, introns, UTRs, and CDS</li> <li><code>Exon</code>, <code>Intron</code>, <code>UTR</code>, <code>CDS</code>: Represent specific genomic features</li> <li><code>Strand</code>: Enumeration for strand orientation (positive/negative)</li> <li><code>Biotype</code>: Enumeration for gene/transcript biotypes</li> <li><code>Phase</code>: Enumeration for CDS phase</li> </ul>"},{"location":"api/#feature-store","title":"Feature Store","text":"<p>The <code>feature_store</code> module provides efficient storage and retrieval of genomic features:</p> <ul> <li><code>GenomicFeatureStore</code>: Main interface for storing and querying features</li> <li><code>IntervalTreeStore</code>: Uses interval trees for efficient range queries</li> <li><code>BinnedGenomicStore</code>: Uses binning for memory-efficient storage</li> <li><code>BruteForceFeatureStore</code>: Simple implementation for testing</li> <li><code>MsiChromosomeStore</code>: Specialized for microsatellite instability sites</li> </ul>"},{"location":"api/#sequences","title":"Sequences","text":"<p>The <code>sequences</code> module provides memory-efficient representations of DNA and RNA sequences:</p> <ul> <li><code>BaseSequence</code>: Abstract base class for nucleotide sequences</li> <li><code>DnaString</code>: Memory-efficient 2-bit representation of DNA sequences</li> <li><code>RnaString</code>: RNA sequence representation</li> <li><code>DnaStringArray</code>: Efficient storage for multiple DNA sequences</li> </ul>"},{"location":"api/#parsers","title":"Parsers","text":"<p>The <code>parsers</code> module includes parsers for common genomic file formats:</p> <ul> <li><code>GenomeLoader</code>: Loads genomes from annotation and sequence files</li> <li><code>FastaParser</code>: Parses FASTA files</li> <li><code>FastqParser</code>: Parses FASTQ files</li> <li><code>GffParser</code>, <code>Gff3Parser</code>, <code>GtfParser</code>: Parse GFF/GTF annotation files</li> <li><code>VcfReader</code>: Parses VCF variant files</li> <li><code>MsiSitesReader</code>: Parses microsatellite instability sites</li> </ul>"},{"location":"api/#module-relationships","title":"Module Relationships","text":"<p>The modules in PyGnome are designed to work together:</p> <ol> <li>Parsers read genomic data from files</li> <li>Genomics models represent the parsed data as objects</li> <li>Feature Stores provide efficient storage and retrieval of genomic features</li> <li>Sequences provide memory-efficient representation of DNA/RNA sequences</li> </ol>"},{"location":"api/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"api/#loading-and-querying-a-genome","title":"Loading and Querying a Genome","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.genome_loader import GenomeLoader\nfrom pygnome.feature_store.genomic_feature_store import GenomicFeatureStore\n\n# Load a genome\nloader = GenomeLoader(genome_name=\"GRCh38\", species=\"Homo sapiens\")\ngenome = loader.load(\n    annotation_file=Path(\"path/to/annotations.gtf\"),\n    sequence_file=Path(\"path/to/genome.fa.gz\")\n)\n\n# Create a feature store for efficient querying\nstore = GenomicFeatureStore()\nwith store:\n    for gene in genome.genes.values():\n        store.add(gene)\n        for transcript in gene.transcripts:\n            store.add(transcript)\n            for exon in transcript.exons:\n                store.add(exon)\n\n# Query features\nfeatures = store.get_by_interval(\"chr1\", 1000000, 2000000)\n</code></pre>"},{"location":"api/#working-with-sequences","title":"Working with Sequences","text":"<pre><code>from pygnome.sequences.dna_string import DnaString\nfrom pygnome.sequences.rna_string import RnaString\n\n# Create a DNA sequence\ndna = DnaString(\"ATGCATGCATGC\")\n\n# Get a subsequence\nsubseq = dna[3:9]\n\n# Complement and reverse complement\ncomp = dna.complement()\nrev_comp = dna.reverse_complement()\n\n# Transcribe DNA to RNA\nrna = dna.transcribe()\n\n# Translate RNA to protein\nprotein = rna.translate()\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>PyGnome uses Python's built-in exception handling. Common exceptions include:</p> <ul> <li><code>ValueError</code>: Raised when a function receives an argument of the correct type but an inappropriate value</li> <li><code>TypeError</code>: Raised when an operation or function is applied to an object of inappropriate type</li> <li><code>IndexError</code>: Raised when a sequence subscript is out of range</li> <li><code>FileNotFoundError</code>: Raised when a file or directory is requested but doesn't exist</li> </ul> <p>Example of error handling:</p> <p>```python from pathlib import Path from pygnome.parsers.fasta.fasta_parser import FastaParser</p> <p>try:     parser = FastaParser(Path(\"path/to/nonexistent_file.fa\"))     records = parser.load() except FileNotFoundError as e:     print(f\"Error: {e}\")     # Handle the error appropriately</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>genomics</li> <li>parsers</li> <li>sequences</li> <li>feature_store</li> </ul>"},{"location":"api/feature-store/","title":"Genomic Feature Store","text":"<p>The <code>feature_store</code> module provides efficient storage and retrieval of genomic features. It offers multiple implementations with different performance characteristics to suit various use cases.</p>"},{"location":"api/feature-store/#overview","title":"Overview","text":"<p>Genomic feature stores are one of the core solutions in PyGnome, providing specialized data structures for efficient storage, indexing, and querying of genomic features based on their genomic coordinates. They solve the fundamental bioinformatics challenge of quickly locating genomic elements within large genomes.</p>"},{"location":"api/feature-store/#what-is-a-genomic-feature-store","title":"What is a Genomic Feature Store?","text":"<p>A genomic feature store is a data structure that:</p> <ol> <li>Stores genomic features (genes, transcripts, exons, variants, etc.) organized by their chromosomal locations</li> <li>Indexes these features using efficient spatial data structures (interval trees, binning, etc.)</li> <li>Provides fast query operations to find features based on genomic coordinates</li> <li>Optimizes memory usage through various implementation strategies</li> </ol> <p>The feature store is designed to efficiently store and query genomic features based on their genomic coordinates. It supports several types of queries:</p> <ul> <li>Position queries: Find all features at a specific position</li> <li>Interval queries: Find all features that overlap with a given range</li> <li>Nearest feature queries: Find the nearest feature to a specific position</li> </ul>"},{"location":"api/feature-store/#core-components","title":"Core Components","text":""},{"location":"api/feature-store/#genomicfeaturestoreprotocol","title":"GenomicFeatureStoreProtocol","text":"<pre><code>class GenomicFeatureStoreProtocol(Protocol):\n</code></pre> <p>This protocol defines the interface that all feature store implementations must follow. It includes methods for adding features, querying features, and managing the store.</p>"},{"location":"api/feature-store/#methods","title":"Methods","text":"Method Description <code>add(feature: GenomicFeature) -&gt; None</code> Add a genomic feature to the store <code>get_by_position(chrom: str, position: int) -&gt; list[GenomicFeature]</code> Get all features at a specific position <code>get_by_interval(chrom: str, start: int, end: int) -&gt; list[GenomicFeature]</code> Get all features that overlap with the given range <code>get_nearest(chrom: str, position: int, max_distance: int = MAX_DISTANCE) -&gt; GenomicFeature \\| None</code> Get the nearest feature to the given position <code>__getitem__(chrom: str) -&gt; ChromosomeFeatureStore</code> Get a chromosome store by name <code>__iterator__()</code> Iterate over all chromosome stores <code>trim() -&gt; None</code> Trim internal data structures to reduce memory usage"},{"location":"api/feature-store/#genomicfeaturestore","title":"GenomicFeatureStore","text":"<pre><code>class GenomicFeatureStore(GenomicFeatureStoreProtocol):\n</code></pre> <p>The main implementation of the genomic feature store. It delegates storage and queries to chromosome-specific stores based on the chosen store type.</p>"},{"location":"api/feature-store/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, store_type: StoreType | str = StoreType.INTERVAL_TREE, bin_size: int = 100000):\n</code></pre> <ul> <li><code>store_type</code>: Type of store to use (default: <code>StoreType.INTERVAL_TREE</code>)</li> <li><code>bin_size</code>: Size of bins for the binned store (default: 100000)</li> </ul>"},{"location":"api/feature-store/#methods_1","title":"Methods","text":"Method Description <code>add(feature: GenomicFeature) -&gt; None</code> Add a genomic feature to the store <code>add_features(features: list[GenomicFeature]) -&gt; None</code> Add multiple genomic features to the store <code>get_by_position(chrom: str, position: int) -&gt; list[GenomicFeature]</code> Get all features at a specific position <code>get_by_interval(chrom: str, start: int, end: int) -&gt; list[GenomicFeature]</code> Get all features that overlap with the given range <code>get_nearest(chrom: str, position: int, max_distance: int = MAX_DISTANCE) -&gt; GenomicFeature \\| None</code> Get the nearest feature to the given position <code>get_chromosomes() -&gt; list[str]</code> Get all chromosome names in the store <code>get_feature_count(chrom: str \\| None = None) -&gt; int</code> Get the number of features in the store <code>trim() -&gt; None</code> Trim internal data structures to reduce memory usage <code>save(filepath: Path) -&gt; None</code> Save the genomic feature store to a file using pickle <code>load(filepath: Path) -&gt; GenomicFeatureStore</code> Load a genomic feature store from a file"},{"location":"api/feature-store/#context-manager","title":"Context Manager","text":"<p>The <code>GenomicFeatureStore</code> class implements the context manager protocol (<code>__enter__</code> and <code>__exit__</code> methods), which should be used when adding features to ensure proper indexing:</p> <pre><code>with store:\n    for feature in features:\n        store.add(feature)\n</code></pre>"},{"location":"api/feature-store/#storetype","title":"StoreType","text":"<pre><code>class StoreType(str, Enum):\n</code></pre> <p>An enumeration of the available feature store types.</p> Value Description <code>INTERVAL_TREE</code> Uses interval trees for efficient range queries <code>BINNED</code> Uses binning for memory-efficient storage <code>BRUTE_FORCE</code> Simple implementation for testing <code>MSI</code> Specialized for microsatellite instability sites"},{"location":"api/feature-store/#chromosomefeaturestore","title":"ChromosomeFeatureStore","text":"<pre><code>class ChromosomeFeatureStore(ABC):\n</code></pre> <p>Abstract base class for chromosome-specific genomic feature storage. It has a list of features and provides methods to add and query them.</p>"},{"location":"api/feature-store/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, chromosome: str) -&gt; None:\n</code></pre> <ul> <li><code>chromosome</code>: Name of the chromosome</li> </ul>"},{"location":"api/feature-store/#methods_2","title":"Methods","text":"Method Description <code>add(feature: GenomicFeature) -&gt; None</code> Add a feature to this chromosome's store <code>get_by_position(position: int) -&gt; list[GenomicFeature]</code> Get all features at a specific position <code>get_by_interval(start: int, end: int) -&gt; list[GenomicFeature]</code> Get all features that overlap with the given range <code>get_features() -&gt; list[GenomicFeature]</code> Get all features <code>get_nearest(position: int, max_distance: int = MAX_DISTANCE) -&gt; GenomicFeature \\| None</code> Get the nearest feature to the given position <code>index_build_start() -&gt; None</code> Start building the index <code>index_build_end() -&gt; None</code> Finish building the index <code>trim() -&gt; None</code> Trim internal data structures to reduce memory usage"},{"location":"api/feature-store/#store-implementations","title":"Store Implementations","text":""},{"location":"api/feature-store/#intervaltreestore","title":"IntervalTreeStore","text":"<pre><code>class IntervalTreeStore(ChromosomeFeatureStore):\n</code></pre> <p>Store genomic features using an efficient interval tree. This is the default implementation and provides a good balance between memory usage and query speed.</p>"},{"location":"api/feature-store/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Memory Usage: Medium</li> <li>Query Speed: Fast</li> <li>Best For: General purpose, balanced performance</li> </ul>"},{"location":"api/feature-store/#binnedgenomicstore","title":"BinnedGenomicStore","text":"<pre><code>class BinnedGenomicStore(ChromosomeFeatureStore):\n</code></pre> <p>Store genomic features using a memory-efficient binning approach. Features are grouped into bins based on their genomic coordinates, which allows for efficient range queries while using less memory than interval trees.</p>"},{"location":"api/feature-store/#constructor_2","title":"Constructor","text":"<pre><code>def __init__(self, chromosome: str, bin_size: int = DEFAULT_BIN_SIZE):\n</code></pre> <ul> <li><code>chromosome</code>: Name of the chromosome</li> <li><code>bin_size</code>: Size of each bin in base pairs (default: 100000)</li> </ul>"},{"location":"api/feature-store/#performance-characteristics_1","title":"Performance Characteristics","text":"<ul> <li>Memory Usage: Low</li> <li>Query Speed: Medium</li> <li>Best For: Large genomes, memory-constrained environments</li> </ul>"},{"location":"api/feature-store/#bruteforcefeaturestore","title":"BruteForceFeatureStore","text":"<pre><code>class BruteForceFeatureStore(ChromosomeFeatureStore):\n</code></pre> <p>A naive brute-force implementation for genomic feature storage. This is not memory efficient and is not recommended for large datasets. It is primarily for testing purposes.</p>"},{"location":"api/feature-store/#performance-characteristics_2","title":"Performance Characteristics","text":"<ul> <li>Memory Usage: Very Low</li> <li>Query Speed: Slow</li> <li>Best For: Testing, very small datasets</li> </ul>"},{"location":"api/feature-store/#msichromosomestore","title":"MsiChromosomeStore","text":"<pre><code>class MsiChromosomeStore(ChromosomeFeatureStore):\n</code></pre> <p>Efficient storage for millions of MSI (Microsatellite Instability) sites in a chromosome. Uses NumPy arrays and DnaStringArray for memory efficiency. Implements binary search for efficient querying.</p>"},{"location":"api/feature-store/#constructor_3","title":"Constructor","text":"<pre><code>def __init__(self, chrom: str, feature_count: int = DEFAULT_FEATURE_COUNT, max_lengths_by_bin: dict[int, int] | None = None, bin_size: int = DEFAULT_BIN_SIZE):\n</code></pre> <ul> <li><code>chrom</code>: Name of the chromosome</li> <li><code>feature_count</code>: Number of features to allocate space for (default: 1024)</li> <li><code>max_lengths_by_bin</code>: Dictionary mapping bin IDs to maximum feature length in that bin</li> <li><code>bin_size</code>: Size of each bin in base pairs (default: 100000)</li> </ul>"},{"location":"api/feature-store/#performance-characteristics_3","title":"Performance Characteristics","text":"<ul> <li>Memory Usage: Very Low</li> <li>Query Speed: Fast</li> <li>Best For: Specialized for microsatellite sites</li> </ul>"},{"location":"api/feature-store/#usage-examples","title":"Usage Examples","text":""},{"location":"api/feature-store/#basic-usage","title":"Basic Usage","text":"<pre><code>from pygnome.feature_store.genomic_feature_store import GenomicFeatureStore\nfrom pygnome.genomics.gene import Gene\nfrom pygnome.genomics.strand import Strand\n\n# Create a feature store\nstore = GenomicFeatureStore()\n\n# Create some features\ngene1 = Gene(id=\"GENE001\", chrom=\"chr1\", start=1000, end=5000, strand=Strand.POSITIVE)\ngene2 = Gene(id=\"GENE002\", chrom=\"chr1\", start=7000, end=9000, strand=Strand.NEGATIVE)\ngene3 = Gene(id=\"GENE003\", chrom=\"chr2\", start=2000, end=6000, strand=Strand.POSITIVE)\n\n# Add features to the store\nwith store:  # Use context manager to ensure proper indexing\n    store.add(gene1)\n    store.add(gene2)\n    store.add(gene3)\n\n# Query features\nfeatures_at_position = store.get_by_position(\"chr1\", 1500)\nprint(f\"Features at position chr1:1500: {features_at_position}\")\n\nfeatures_in_range = store.get_by_interval(\"chr1\", 4000, 8000)\nprint(f\"Features in range chr1:4000-8000: {features_in_range}\")\n\nnearest_feature = store.get_nearest(\"chr1\", 6000)\nprint(f\"Nearest feature to chr1:6000: {nearest_feature}\")\n</code></pre>"},{"location":"api/feature-store/#choosing-a-store-type","title":"Choosing a Store Type","text":"<pre><code>from pygnome.feature_store.genomic_feature_store import GenomicFeatureStore, StoreType\n\n# Create a feature store with interval trees (default)\ndefault_store = GenomicFeatureStore()\n\n# Create a feature store with binning\nbinned_store = GenomicFeatureStore(store_type=StoreType.BINNED, bin_size=100000)\n\n# Create a feature store with brute force\nbrute_force_store = GenomicFeatureStore(store_type=StoreType.BRUTE_FORCE)\n\n# Create a feature store for MSI sites\nmsi_store = GenomicFeatureStore(store_type=StoreType.MSI)\n</code></pre>"},{"location":"api/feature-store/#saving-and-loading","title":"Saving and Loading","text":"<pre><code>from pathlib import Path\nfrom pygnome.feature_store.genomic_feature_store import GenomicFeatureStore\n\n# Create and populate a feature store\nstore = GenomicFeatureStore()\n# ... add features ...\n\n# Trim the store to reduce memory usage\nstore.trim()\n\n# Save the store\nstore.save(Path(\"path/to/store.pkl\"))\n\n# Load the store\nloaded_store = GenomicFeatureStore.load(Path(\"path/to/store.pkl\"))\n</code></pre>"},{"location":"api/feature-store/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/feature-store/#memory-usage","title":"Memory Usage","text":"<p>The memory usage of the feature store depends on the implementation:</p> <ul> <li><code>IntervalTreeStore</code>: Uses more memory but provides faster queries</li> <li><code>BinnedGenomicStore</code>: Uses less memory but queries may be slightly slower</li> <li><code>BruteForceFeatureStore</code>: Uses minimal memory but queries are slow</li> <li><code>MsiChromosomeStore</code>: Specialized for MSI sites, very memory efficient</li> </ul>"},{"location":"api/feature-store/#query-speed","title":"Query Speed","text":"<p>The query speed depends on the implementation and the number of features:</p> <ul> <li><code>IntervalTreeStore</code>: O(log n + k) for finding k intervals that overlap with a given point or range</li> <li><code>BinnedGenomicStore</code>: O(b + k) where b is the number of bins that overlap with the query range</li> <li><code>BruteForceFeatureStore</code>: O(n) where n is the total number of features</li> <li><code>MsiChromosomeStore</code>: O(log n + k) using binary search</li> </ul>"},{"location":"api/feature-store/#best-practices","title":"Best Practices","text":"<ol> <li>Use the context manager pattern when adding features to ensure proper indexing</li> <li>Choose the appropriate store type based on your specific use case</li> <li>For large genomes, consider saving the populated store to disk with <code>store.save()</code> for faster loading in future sessions</li> </ol>"},{"location":"api/feature-store/#build-time-vs-load-time","title":"Build Time vs. Load Time","text":"<p>Building genomic feature stores with large datasets can be time-consuming, especially when creating indexes for efficient querying. The build time depends on:</p> <ul> <li>The number of features being added</li> <li>The complexity of the indexing structure (interval trees, binning, etc.)</li> <li>The performance characteristics of the chosen store implementation</li> </ul> <p>However, once built, these stores can be serialized to disk using Python's pickle format. This allows you to quickly load pre-built stores in future sessions, avoiding the need to rebuild them each time:</p> <pre><code># Building a store can be time-consuming\nstore = GenomicFeatureStore()\nwith store:\n    # Adding thousands or millions of features...\n    for gene in genome.genes.values():\n        store.add(gene)\n        for transcript in gene.transcripts:\n            store.add(transcript)\n            # ...and so on\n\n# Save the built store to avoid rebuilding it next time\n# Note: trimming is done automatically during save\nstore.save(Path(\"path/to/store.pkl\"))\n\n# In future sessions, quickly load the pre-built store\nloaded_store = GenomicFeatureStore.load(Path(\"path/to/store.pkl\"))\n# Ready to use immediately without rebuilding indexes\n</code></pre> <p>This approach is particularly valuable in production environments or when working with large reference genomes where the feature set doesn't change frequently.</p>"},{"location":"api/genomics/","title":"Genomics","text":"<p>The <code>genomics</code> module provides the core data models for representing genomic features. It includes classes for representing genomes, chromosomes, genes, transcripts, and other genomic features.</p>"},{"location":"api/genomics/#overview","title":"Overview","text":"<p>The genomics module is built around a hierarchy of classes that represent different levels of genomic organization:</p> <ol> <li><code>Genome</code>: Top-level container for chromosomes and genes</li> <li><code>Chromosome</code>: Contains genes and sequence data</li> <li><code>Gene</code>: Represents a gene with transcripts</li> <li><code>Transcript</code>: Represents a transcript with exons, introns, UTRs, and CDS</li> <li><code>Exon</code>, <code>Intron</code>, <code>UTR</code>, <code>CDS</code>: Represent specific genomic features</li> </ol> <p>All genomic features inherit from the <code>GenomicFeature</code> base class, which provides common functionality for working with genomic coordinates.</p>"},{"location":"api/genomics/#core-classes","title":"Core Classes","text":""},{"location":"api/genomics/#genomicfeature","title":"GenomicFeature","text":"<pre><code>@dataclass\nclass GenomicFeature:\n</code></pre> <p>Base class for all genomic features. Uses 0-based, half-open interval coordinates [start, end) where start is included but end is excluded. Length is calculated as (end - start).</p>"},{"location":"api/genomics/#attributes","title":"Attributes","text":"Attribute Type Description <code>id</code> <code>str</code> Unique identifier for the feature <code>chrom</code> <code>str</code> Chromosome name <code>start</code> <code>int</code> Start position (0-based, inclusive) <code>end</code> <code>int</code> End position (0-based, exclusive) <code>strand</code> <code>Strand</code> Strand orientation (positive/negative)"},{"location":"api/genomics/#properties","title":"Properties","text":"Property Type Description <code>length</code> <code>int</code> Length of the feature (end - start)"},{"location":"api/genomics/#methods","title":"Methods","text":"Method Description <code>intersects_point(position: int) -&gt; bool</code> Check if the feature intersects with a specific point <code>intersects_interval(start: int, end: int) -&gt; bool</code> Check if the feature intersects with a specific interval <code>intersects(other: GenomicFeature) -&gt; bool</code> Check if the feature intersects with another feature <code>contains(other: GenomicFeature) -&gt; bool</code> Check if the feature contains another feature <code>distance(position: int) -&gt; int</code> Calculate the distance from a point to the feature"},{"location":"api/genomics/#genome","title":"Genome","text":"<pre><code>class Genome:\n</code></pre> <p>A genome containing chromosomes and genes.</p>"},{"location":"api/genomics/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, name: str, species: str | None = None, codon_table_type: CodonTableType = CodonTableType.STANDARD):\n</code></pre> <ul> <li><code>name</code>: Name of the genome</li> <li><code>species</code>: Species name (optional)</li> <li><code>codon_table_type</code>: Type of codon table to use for translation (default: <code>CodonTableType.STANDARD</code>)</li> </ul>"},{"location":"api/genomics/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> Name of the genome <code>species</code> <code>str \\| None</code> Species name <code>codon_table_type</code> <code>CodonTableType</code> Type of codon table to use for translation <code>chromosomes</code> <code>dict[str, Chromosome]</code> Dictionary of chromosomes by name <code>genes</code> <code>dict[str, Gene]</code> Dictionary of genes by ID"},{"location":"api/genomics/#methods_1","title":"Methods","text":"Method Description <code>add_chromosome(chromosome: Chromosome) -&gt; None</code> Add a chromosome to the genome <code>get_chromosome(chrom_name: str) -&gt; Chromosome \\| None</code> Get a chromosome by name <code>get_gene(gene_id: str) -&gt; Gene \\| None</code> Get a gene by ID <code>get_gene_by_name(gene_name: str) -&gt; list[Gene]</code> Get genes by name <code>get_genes_by_biotype(biotype: str) -&gt; list[Gene]</code> Get genes by biotype"},{"location":"api/genomics/#chromosome","title":"Chromosome","text":"<pre><code>class Chromosome:\n</code></pre> <p>A chromosome containing genes and optionally a DNA sequence.</p>"},{"location":"api/genomics/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, name: str, length: int | None = None, sequence: DnaString | None = None):\n</code></pre> <ul> <li><code>name</code>: Name of the chromosome</li> <li><code>length</code>: Length of the chromosome in base pairs (optional)</li> <li><code>sequence</code>: DNA sequence of the chromosome (optional)</li> </ul>"},{"location":"api/genomics/#attributes_2","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> Name of the chromosome <code>sequence</code> <code>DnaString \\| None</code> DNA sequence of the chromosome <code>genes</code> <code>dict[str, Gene]</code> Dictionary of genes by ID <code>genome</code> <code>Genome \\| None</code> Reference to the parent genome"},{"location":"api/genomics/#properties_1","title":"Properties","text":"Property Type Description <code>length</code> <code>int \\| None</code> Length of the chromosome in base pairs"},{"location":"api/genomics/#methods_2","title":"Methods","text":"Method Description <code>add_gene(gene: Gene) -&gt; None</code> Add a gene to the chromosome <code>add_genes(genes: list[Gene]) -&gt; None</code> Add multiple genes to the chromosome <code>get_gene(gene_id: str) -&gt; Gene \\| None</code> Get a gene by ID <code>get_genes_in_region(start: int, end: int) -&gt; list[Gene]</code> Get all genes that overlap a genomic region"},{"location":"api/genomics/#gene","title":"Gene","text":"<pre><code>@dataclass\nclass Gene(GenomicFeature):\n</code></pre> <p>A gene, which may have multiple transcripts.</p>"},{"location":"api/genomics/#attributes_3","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str \\| None</code> Gene name <code>biotype</code> <code>Biotype \\| None</code> Gene biotype <code>transcripts</code> <code>list[Transcript]</code> List of transcripts <code>chromosome</code> <code>Chromosome \\| None</code> Reference to the parent chromosome"},{"location":"api/genomics/#properties_2","title":"Properties","text":"Property Type Description <code>canonical_transcript</code> <code>Transcript \\| None</code> Return the canonical transcript, if defined <code>is_coding</code> <code>bool</code> Return True if any transcript has coding sequence"},{"location":"api/genomics/#methods_3","title":"Methods","text":"Method Description <code>add_transcript(transcript: Transcript) -&gt; None</code> Add a transcript to the gene"},{"location":"api/genomics/#transcript","title":"Transcript","text":"<pre><code>@dataclass\nclass Transcript(GenomicFeature):\n</code></pre> <p>A transcript of a gene, composed of exons, introns, UTRs, and CDS segments.</p>"},{"location":"api/genomics/#attributes_4","title":"Attributes","text":"Attribute Type Description <code>gene_id</code> <code>str</code> ID of the parent gene <code>biotype</code> <code>Biotype \\| None</code> Transcript biotype <code>exons</code> <code>list[Exon]</code> List of exons <code>cds_list</code> <code>list[CDS]</code> List of CDS segments <code>utrs</code> <code>list[UTR]</code> List of UTRs <code>introns</code> <code>list[Intron]</code> List of introns <code>splice_sites</code> <code>list[SpliceSite]</code> List of splice sites <code>gene</code> <code>Gene \\| None</code> Reference to the parent gene"},{"location":"api/genomics/#properties_3","title":"Properties","text":"Property Type Description <code>coding_length</code> <code>int</code> Total length of coding sequence <code>exonic_length</code> <code>int</code> Total length of exons <code>is_coding</code> <code>bool</code> Return True if the transcript has coding sequence <code>five_prime_utrs</code> <code>list[UTR]</code> Return all 5' UTRs <code>three_prime_utrs</code> <code>list[UTR]</code> Return all 3' UTRs"},{"location":"api/genomics/#methods_4","title":"Methods","text":"Method Description <code>cds(genome_sequence: dict[str, str]) -&gt; str</code> Get the coding DNA sequence for this transcript <code>protein(genome_sequence: dict[str, str]) -&gt; str</code> Get the protein sequence for this transcript"},{"location":"api/genomics/#enumerations","title":"Enumerations","text":""},{"location":"api/genomics/#strand","title":"Strand","text":"<pre><code>class Strand(str, Enum):\n</code></pre> <p>Enumeration for strand orientation.</p> Value Description <code>POSITIVE</code> Positive strand (+) <code>NEGATIVE</code> Negative strand (-) <code>UNKNOWN</code> Unknown strand (.)"},{"location":"api/genomics/#biotype","title":"Biotype","text":"<pre><code>class Biotype(str, Enum):\n</code></pre> <p>Enumeration for gene/transcript biotypes.</p> Value Description <code>PROTEIN_CODING</code> Protein-coding gene/transcript <code>NONCODING</code> Non-coding gene/transcript <code>PSEUDOGENE</code> Pseudogene <code>UNKNOWN</code> Unknown biotype"},{"location":"api/genomics/#phase","title":"Phase","text":"<pre><code>class Phase(int, Enum):\n</code></pre> <p>Enumeration for CDS phase.</p> Value Description <code>ZERO</code> Phase 0 (0) <code>ONE</code> Phase 1 (1) <code>TWO</code> Phase 2 (2) <code>UNKNOWN</code> Unknown phase (-1)"},{"location":"api/genomics/#usage-examples","title":"Usage Examples","text":""},{"location":"api/genomics/#creating-a-genome","title":"Creating a Genome","text":"<pre><code>from pygnome.genomics.genome import Genome\nfrom pygnome.genomics.chromosome import Chromosome\nfrom pygnome.genomics.gene import Gene\nfrom pygnome.genomics.transcript import Transcript\nfrom pygnome.genomics.exon import Exon\nfrom pygnome.genomics.strand import Strand\n\n# Create a genome\ngenome = Genome(name=\"MyGenome\", species=\"Example species\")\n\n# Create a chromosome\nchromosome = Chromosome(name=\"chr1\", length=248956422)\n\n# Add the chromosome to the genome\ngenome.add_chromosome(chromosome)\n\n# Create a gene\ngene = Gene(\n    id=\"GENE001\",\n    name=\"Example Gene\",\n    chrom=\"chr1\",\n    start=1000,\n    end=5000,\n    strand=Strand.POSITIVE\n)\n\n# Create a transcript\ntranscript = Transcript(\n    id=\"TRANSCRIPT001\",\n    gene_id=\"GENE001\",\n    chrom=\"chr1\",\n    start=1000,\n    end=5000,\n    strand=Strand.POSITIVE\n)\n\n# Create exons\nexon1 = Exon(\n    id=\"EXON001\",\n    chrom=\"chr1\",\n    start=1000,\n    end=2000,\n    strand=Strand.POSITIVE\n)\n\nexon2 = Exon(\n    id=\"EXON002\",\n    chrom=\"chr1\",\n    start=3000,\n    end=5000,\n    strand=Strand.POSITIVE\n)\n\n# Add exons to transcript\ntranscript.exons = [exon1, exon2]\n\n# Add transcript to gene\ngene.add_transcript(transcript)\n\n# Add gene to chromosome\nchromosome.add_gene(gene)\n\n# Now the gene is also accessible from the genome\nprint(genome.genes[\"GENE001\"])\n</code></pre>"},{"location":"api/genomics/#working-with-genomic-features","title":"Working with Genomic Features","text":"<pre><code>from pygnome.genomics.gene import Gene\nfrom pygnome.genomics.strand import Strand\n\n# Create two genes\ngene1 = Gene(\n    id=\"GENE001\",\n    name=\"Gene 1\",\n    chrom=\"chr1\",\n    start=1000,\n    end=5000,\n    strand=Strand.POSITIVE\n)\n\ngene2 = Gene(\n    id=\"GENE002\",\n    name=\"Gene 2\",\n    chrom=\"chr1\",\n    start=4000,\n    end=7000,\n    strand=Strand.NEGATIVE\n)\n\n# Check if the genes intersect\nif gene1.intersects(gene2):\n    print(f\"{gene1.id} intersects with {gene2.id}\")\n\n# Check if a position is within a gene\nposition = 3000\nif gene1.intersects_point(position):\n    print(f\"Position {position} is within {gene1.id}\")\n\n# Calculate the distance from a position to a gene\nposition = 6000\ndistance = gene1.distance(position)\nprint(f\"Distance from position {position} to {gene1.id}: {distance}\")\n</code></pre>"},{"location":"api/parsers/","title":"Parsers","text":"<p>The <code>parsers</code> module provides parsers for common genomic file formats. It includes parsers for FASTA/FASTQ, GFF/GTF, VCF, and MSI formats.</p>"},{"location":"api/parsers/#overview","title":"Overview","text":"<p>The parsers module is designed to efficiently read and parse genomic data from various file formats. It provides a consistent interface for working with different file formats and converts the parsed data into PyGnome's object model.</p> <p>Key features:</p> <ul> <li>Support for common genomic file formats (FASTA, FASTQ, GFF, GTF, VCF)</li> <li>Memory-efficient parsing of large files</li> <li>Conversion of parsed data into PyGnome's object model</li> <li>Support for compressed files (gzip, bgzip)</li> </ul>"},{"location":"api/parsers/#fastafastq-parsers","title":"FASTA/FASTQ Parsers","text":""},{"location":"api/parsers/#fastaparser","title":"FastaParser","text":"<pre><code>class FastaParser:\n</code></pre> <p>Parser for FASTA files. FASTA is a text-based format for representing nucleotide or peptide sequences.</p>"},{"location":"api/parsers/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, filepath: Path):\n</code></pre> <ul> <li><code>filepath</code>: Path to the FASTA file</li> </ul>"},{"location":"api/parsers/#methods","title":"Methods","text":"Method Description <code>load() -&gt; list[FastaRecord]</code> Load all records from the FASTA file <code>load_as_dict() -&gt; dict[str, FastaRecord]</code> Load all records from the FASTA file as a dictionary <code>parse_as_dna_strings(filepath: Path) -&gt; dict[str, DnaString]</code> Parse a FASTA file and return a dictionary of DnaString objects"},{"location":"api/parsers/#fastqparser","title":"FastqParser","text":"<pre><code>class FastqParser:\n</code></pre> <p>Parser for FASTQ files. FASTQ is a text-based format for storing both a nucleotide sequence and its corresponding quality scores.</p>"},{"location":"api/parsers/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, filepath: Path):\n</code></pre> <ul> <li><code>filepath</code>: Path to the FASTQ file</li> </ul>"},{"location":"api/parsers/#methods_1","title":"Methods","text":"Method Description <code>load() -&gt; list[FastqRecord]</code> Load all records from the FASTQ file <code>load_as_dict() -&gt; dict[str, FastqRecord]</code> Load all records from the FASTQ file as a dictionary"},{"location":"api/parsers/#gffgtf-parsers","title":"GFF/GTF Parsers","text":""},{"location":"api/parsers/#gffparser","title":"GffParser","text":"<pre><code>class GffParser:\n</code></pre> <p>Base class for GFF/GTF parsers. GFF (General Feature Format) and GTF (Gene Transfer Format) are tab-delimited text formats for describing genes and other features of DNA, RNA, and protein sequences.</p>"},{"location":"api/parsers/#constructor_2","title":"Constructor","text":"<pre><code>def __init__(self, filepath: Path):\n</code></pre> <ul> <li><code>filepath</code>: Path to the GFF/GTF file</li> </ul>"},{"location":"api/parsers/#methods_2","title":"Methods","text":"Method Description <code>__iter__() -&gt; Iterator[GffRecord]</code> Iterate over records in the GFF/GTF file <code>parse_attributes(attributes_str: str) -&gt; dict[str, str]</code> Parse the attributes field of a GFF/GTF record"},{"location":"api/parsers/#gff3parser","title":"Gff3Parser","text":"<pre><code>class Gff3Parser(GffParser):\n</code></pre> <p>Parser for GFF3 files. GFF3 is the latest version of the General Feature Format.</p>"},{"location":"api/parsers/#constructor_3","title":"Constructor","text":"<pre><code>def __init__(self, filepath: Path):\n</code></pre> <ul> <li><code>filepath</code>: Path to the GFF3 file</li> </ul>"},{"location":"api/parsers/#gtfparser","title":"GtfParser","text":"<pre><code>class GtfParser(GffParser):\n</code></pre> <p>Parser for GTF files. GTF (Gene Transfer Format) is a refinement of GFF that is used to describe genes and other features of DNA, RNA, and protein sequences.</p>"},{"location":"api/parsers/#constructor_4","title":"Constructor","text":"<pre><code>def __init__(self, filepath: Path):\n</code></pre> <ul> <li><code>filepath</code>: Path to the GTF file</li> </ul>"},{"location":"api/parsers/#vcf-parsers","title":"VCF Parsers","text":""},{"location":"api/parsers/#vcfreader","title":"VcfReader","text":"<pre><code>class VcfReader:\n</code></pre> <p>Parser for VCF files. VCF (Variant Call Format) is a text file format for storing gene sequence variations.</p>"},{"location":"api/parsers/#constructor_5","title":"Constructor","text":"<pre><code>def __init__(self, filepath: Path):\n</code></pre> <ul> <li><code>filepath</code>: Path to the VCF file</li> </ul>"},{"location":"api/parsers/#methods_3","title":"Methods","text":"Method Description <code>__iter__() -&gt; Iterator[VcfRecord]</code> Iterate over records in the VCF file <code>get_samples() -&gt; list[str]</code> Get the sample names from the VCF file <code>get_header() -&gt; VcfHeader</code> Get the header from the VCF file <code>fetch(chrom: str, start: int, end: int) -&gt; Iterator[VcfRecord]</code> Fetch records in a specific region"},{"location":"api/parsers/#msi-parsers","title":"MSI Parsers","text":""},{"location":"api/parsers/#msisitesreader","title":"MsiSitesReader","text":"<pre><code>class MsiSitesReader:\n</code></pre> <p>Parser for MSI (Microsatellite Instability) sites files. MSI sites are regions of the genome with repetitive DNA sequences.</p>"},{"location":"api/parsers/#constructor_6","title":"Constructor","text":"<pre><code>def __init__(self, filepath: Path):\n</code></pre> <ul> <li><code>filepath</code>: Path to the MSI sites file</li> </ul>"},{"location":"api/parsers/#methods_4","title":"Methods","text":"Method Description <code>read_all() -&gt; list[MsiSiteRecord]</code> Read all MSI sites from the file <code>read_by_chromosome(chrom: str) -&gt; list[MsiSiteRecord]</code> Read MSI sites for a specific chromosome"},{"location":"api/parsers/#genome-loader","title":"Genome Loader","text":""},{"location":"api/parsers/#genomeloader","title":"GenomeLoader","text":"<pre><code>class GenomeLoader:\n</code></pre> <p>Class for loading complete genomes from annotation and sequence files. This class combines sequence data from FASTA files with annotation data from GFF/GTF files to build a complete Genome object with chromosomes, genes, transcripts, exons, and other genomic features.</p>"},{"location":"api/parsers/#constructor_7","title":"Constructor","text":"<pre><code>def __init__(self, genome_name: str = \"genome\", species: str = None, verbose: bool = False):\n</code></pre> <ul> <li><code>genome_name</code>: Name of the genome</li> <li><code>species</code>: Species name</li> <li><code>verbose</code>: Whether to print progress information during loading</li> </ul>"},{"location":"api/parsers/#methods_5","title":"Methods","text":"Method Description <code>load(annotation_file: Path, sequence_file: Path) -&gt; Genome</code> Load a genome from annotation and sequence files <code>load_sequences(sequence_file: Path) -&gt; dict[str, Chromosome]</code> Load chromosome sequences from a FASTA file"},{"location":"api/parsers/#usage-examples","title":"Usage Examples","text":""},{"location":"api/parsers/#parsing-fasta-files","title":"Parsing FASTA Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.fasta.fasta_parser import FastaParser\n\n# Parse a FASTA file\nparser = FastaParser(Path(\"path/to/sequences.fa\"))\nrecords = parser.load()\n\n# Access sequences\nfor record in records:\n    print(f\"Sequence: {record.identifier}\")\n    print(f\"Length: {len(record.sequence)}\")\n\n    # Convert to string if needed\n    seq_str = str(record.sequence)\n    print(f\"First 10 bases: {seq_str[:10]}\")\n\n# Load as dictionary for quick access by identifier\nsequences = FastaParser(Path(\"path/to/sequences.fa\")).load_as_dict()\nmy_seq = sequences[\"chr1\"].sequence\n</code></pre>"},{"location":"api/parsers/#parsing-gffgtf-files","title":"Parsing GFF/GTF Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.gff.gff3_parser import Gff3Parser\nfrom pygnome.parsers.gff.gtf_parser import GtfParser\n\n# Parse a GFF3 file\ngff_parser = Gff3Parser(Path(\"path/to/annotations.gff3\"))\nfor record in gff_parser:\n    print(f\"{record.type}: {record.chrom}:{record.start}-{record.end}\")\n    print(f\"Attributes: {record.attributes}\")\n\n# Parse a GTF file\ngtf_parser = GtfParser(Path(\"path/to/annotations.gtf\"))\nfor record in gtf_parser:\n    if record.type == \"gene\":\n        gene_id = record.attributes.get(\"gene_id\")\n        gene_name = record.attributes.get(\"gene_name\")\n        print(f\"Gene: {gene_id} ({gene_name}) - {record.chrom}:{record.start}-{record.end}\")\n</code></pre>"},{"location":"api/parsers/#parsing-vcf-files","title":"Parsing VCF Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.vcf.vcf_reader import VcfReader\n\n# Open a VCF file\nwith VcfReader(Path(\"path/to/variants.vcf\")) as reader:\n    # Get sample names\n    samples = reader.get_samples()\n    print(f\"Samples: {samples}\")\n\n    # Iterate through records\n    for record in reader:\n        print(f\"Record: {record.get_chrom()}:{record.get_pos()} {record.get_ref()}&gt;{','.join(record.get_alt())}\")\n\n        # Create variant objects from the record\n        for variant in record:  # Uses VariantFactory internally\n            print(f\"Variant: {variant}\")\n\n        # Access genotypes\n        genotypes = record.get_genotypes()\n        for i, genotype in enumerate(genotypes):\n            print(f\"  {samples[i]}: {genotype}\")\n\n    # Query a specific region\n    for record in reader.fetch(\"chr1\", 1000000, 2000000):\n        for variant in record:\n            print(f\"Region variant: {variant}\")\n</code></pre>"},{"location":"api/parsers/#loading-a-complete-genome","title":"Loading a Complete Genome","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.genome_loader import GenomeLoader\n\n# Create a genome loader\nloader = GenomeLoader(\n    genome_name=\"GRCh38\",\n    species=\"Homo sapiens\",\n    verbose=True  # Print progress information\n)\n\n# Load genome structure and sequence\ngenome = loader.load(\n    annotation_file=Path(\"path/to/annotations.gtf\"),\n    sequence_file=Path(\"path/to/genome.fa.gz\")\n)\n\n# Access genome components\nprint(f\"Genome: {genome.name} ({genome.species})\")\nprint(f\"Chromosomes: {len(genome.chromosomes)}\")\nprint(f\"Genes: {len(genome.genes)}\")\n\n# Get a specific chromosome\nchr1 = genome.chromosomes.get(\"chr1\")\nif chr1:\n    print(f\"Chromosome: {chr1.name}, Length: {chr1.length}\")\n    print(f\"Genes on chr1: {len(chr1.genes)}\")\n</code></pre>"},{"location":"api/sequences/","title":"Sequences","text":"<p>The <code>sequences</code> module provides memory-efficient representations of DNA and RNA sequences. It includes classes for representing individual sequences and collections of sequences.</p>"},{"location":"api/sequences/#overview","title":"Overview","text":"<p>The sequences module is designed to efficiently store and manipulate nucleotide sequences. It uses a 2-bit encoding for DNA and RNA sequences, which allows for significant memory savings compared to string-based representations.</p> <p>Key features:</p> <ul> <li>Memory-efficient 2-bit representation (A=00, C=01, G=10, T/U=11)</li> <li>Support for common sequence operations (complement, reverse complement, transcription, translation)</li> <li>Efficient storage of multiple sequences in a single array</li> <li>Support for slicing and indexing</li> </ul>"},{"location":"api/sequences/#core-classes","title":"Core Classes","text":""},{"location":"api/sequences/#basesequence","title":"BaseSequence","text":"<pre><code>class BaseSequence(ABC):\n</code></pre> <p>Abstract base class for efficient 2-bit representation of nucleotide sequences. This class provides common functionality for storing nucleotide sequences using 2 bits per nucleotide, allowing 16 nucleotides to be packed into a single 32-bit integer.</p>"},{"location":"api/sequences/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, sequence: str):\n</code></pre> <ul> <li><code>sequence</code>: A string containing nucleotides</li> </ul>"},{"location":"api/sequences/#methods","title":"Methods","text":"Method Description <code>__len__() -&gt; int</code> Return the length of the sequence <code>__str__() -&gt; str</code> Return the sequence as a string <code>__getitem__(key) -&gt; str</code> Get a nucleotide or subsequence <code>to_string() -&gt; str</code> Convert the entire sequence to a string <code>substring(start: int, length: int \\| None = None) -&gt; str</code> Extract a substring from the sequence <code>__eq__(other) -&gt; bool</code> Check if two sequence objects are equal"},{"location":"api/sequences/#dnastring","title":"DnaString","text":"<pre><code>class DnaString(BaseSequence):\n</code></pre> <p>Efficient 2-bit representation of DNA sequences. This class stores DNA sequences (A, C, G, T) using 2 bits per nucleotide, allowing 16 nucleotides to be packed into a single 32-bit integer.</p>"},{"location":"api/sequences/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, sequence: str):\n</code></pre> <ul> <li><code>sequence</code>: A string containing DNA nucleotides (A, C, G, T)</li> </ul>"},{"location":"api/sequences/#methods_1","title":"Methods","text":"Method Description <code>complement() -&gt; DnaString</code> Return the complement of the sequence <code>reverse_complement() -&gt; DnaString</code> Return the reverse complement of the sequence <code>transcribe() -&gt; RnaString</code> Transcribe DNA to RNA <code>gc_content() -&gt; float</code> Calculate the GC content of the sequence"},{"location":"api/sequences/#rnastring","title":"RnaString","text":"<pre><code>class RnaString(BaseSequence):\n</code></pre> <p>Efficient 2-bit representation of RNA sequences. This class stores RNA sequences (A, C, G, U) using 2 bits per nucleotide, allowing 16 nucleotides to be packed into a single 32-bit integer.</p>"},{"location":"api/sequences/#constructor_2","title":"Constructor","text":"<pre><code>def __init__(self, sequence: str):\n</code></pre> <ul> <li><code>sequence</code>: A string containing RNA nucleotides (A, C, G, U)</li> </ul>"},{"location":"api/sequences/#methods_2","title":"Methods","text":"Method Description <code>complement() -&gt; RnaString</code> Return the complement of the sequence <code>reverse_complement() -&gt; RnaString</code> Return the reverse complement of the sequence <code>translate() -&gt; str</code> Translate RNA to protein"},{"location":"api/sequences/#dnastringarray","title":"DnaStringArray","text":"<pre><code>class DnaStringArray:\n</code></pre> <p>Efficient storage for millions of small DNA strings in a single NumPy array. This class stores multiple DNA sequences using the same 2-bit encoding as DnaString, but packs all sequences into a single contiguous array for improved memory efficiency when dealing with large numbers of sequences.</p>"},{"location":"api/sequences/#constructor_3","title":"Constructor","text":"<pre><code>def __init__(self, initial_data_bytes: int = DEFAULT_CAPACITY, initial_strings: int = DEFAULT_NUMBER_OF_STRINGS):\n</code></pre> <ul> <li><code>initial_data_bytes</code>: Initial capacity in bytes for the data array (default: 1MB)</li> <li><code>initial_strings</code>: Initial number of strings the array can hold (default: 100,000)</li> </ul>"},{"location":"api/sequences/#methods_3","title":"Methods","text":"Method Description <code>add(sequence: str) -&gt; int</code> Add a DNA sequence to the array <code>add_multiple(sequences: list[str]) -&gt; list[int]</code> Add multiple DNA sequences to the array <code>get(idx: int) -&gt; str</code> Get a sequence by its index <code>get_subsequence(idx: int, start: int, length: int \\| None = None) -&gt; str</code> Extract a subsequence from a sequence in the array <code>get_length(idx: int) -&gt; int</code> Get the length of a sequence <code>__getitem__(idx: int) -&gt; str</code> Get a sequence by its index <code>__len__() -&gt; int</code> Return the number of sequences in the array <code>trim() -&gt; None</code> Trim the internal arrays to their actual used size <code>get_stats() -&gt; tuple[int, int, float]</code> Get statistics about memory usage <code>to_dna_string(idx: int) -&gt; DnaString</code> Convert a sequence in the array to a DnaString object"},{"location":"api/sequences/#usage-examples","title":"Usage Examples","text":""},{"location":"api/sequences/#working-with-dna-sequences","title":"Working with DNA Sequences","text":"<pre><code>from pygnome.sequences.dna_string import DnaString\n\n# Create a DNA sequence\ndna = DnaString(\"ATGCATGCATGC\")\nprint(f\"Length: {len(dna)}\")\n\n# Get a subsequence\nsubseq = dna[3:9]  # Returns a new DnaString\nprint(f\"Subsequence: {subseq}\")\n\n# Complement and reverse complement\ncomp = dna.complement()\nrev_comp = dna.reverse_complement()\nprint(f\"Complement: {comp}\")\nprint(f\"Reverse complement: {rev_comp}\")\n\n# Transcribe DNA to RNA\nrna = dna.transcribe()  # Returns an RnaString\nprint(f\"RNA: {rna}\")\n</code></pre>"},{"location":"api/sequences/#working-with-rna-sequences","title":"Working with RNA Sequences","text":"<pre><code>from pygnome.sequences.rna_string import RnaString\n\n# Create an RNA sequence\nrna = RnaString(\"AUGCAUGCAUGC\")\nprint(f\"Length: {len(rna)}\")\n\n# Get a subsequence\nsubseq = rna[3:9]  # Returns a new RnaString\nprint(f\"Subsequence: {subseq}\")\n\n# Complement and reverse complement\ncomp = rna.complement()\nrev_comp = rna.reverse_complement()\nprint(f\"Complement: {comp}\")\nprint(f\"Reverse complement: {rev_comp}\")\n\n# Translate RNA to protein\nprotein = rna.translate()\nprint(f\"Protein: {protein}\")\n</code></pre>"},{"location":"api/sequences/#working-with-multiple-sequences","title":"Working with Multiple Sequences","text":"<pre><code>from pygnome.sequences.dna_string_array import DnaStringArray\n\n# Create a DNA string array\narray = DnaStringArray()\n\n# Add sequences\nidx1 = array.add(\"ATGCATGC\")\nidx2 = array.add(\"GCTAGCTA\")\n\n# Add multiple sequences at once\nindices = array.add_multiple([\"AAAAAA\", \"CCCCCC\", \"GGGGGG\"])\n\n# Access sequences\nseq1 = array[idx1]\nprint(f\"Sequence 1: {seq1}\")\n\n# Get subsequences\nsubseq = array.get_subsequence(idx2, 2, 4)\nprint(f\"Subsequence: {subseq}\")\n\n# Get statistics\ncount, total_nt, bits_per_nt = array.get_stats()\nprint(f\"Sequences: {count}, Total nucleotides: {total_nt}, Bits per nucleotide: {bits_per_nt:.2f}\")\n\n# Trim to reduce memory usage\narray.trim()\n</code></pre>"},{"location":"api/sequences/#memory-efficiency","title":"Memory Efficiency","text":"<p>The 2-bit encoding used by the sequences module provides significant memory savings compared to string-based representations:</p> <ul> <li>A standard Python string uses 1 byte (8 bits) per character</li> <li>DnaString and RnaString use 2 bits per nucleotide</li> <li>This results in a 4x reduction in memory usage</li> </ul> <p>For example, a 1 million base pair chromosome would use:</p> <ul> <li>String representation: ~1 MB</li> <li>DnaString representation: ~250 KB</li> </ul> <p>The DnaStringArray class provides even greater memory efficiency when storing multiple sequences by:</p> <ol> <li>Minimizing memory overhead compared to individual DnaString objects</li> <li>Improving cache locality for faster access patterns</li> <li>Reducing memory fragmentation</li> </ol>"},{"location":"api/sequences/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Use DnaStringArray instead of multiple DnaString objects when working with many small sequences</li> <li>Call trim() on DnaStringArray before serialization to reduce memory usage</li> <li>For very large sequences (e.g., entire chromosomes), consider using memory-mapped files or chunked processing</li> </ul>"},{"location":"development/contributing/","title":"Contributing to PyGnome","text":"<p>Thank you for your interest in contributing to PyGnome! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>Git</li> <li>A GitHub account</li> </ul>"},{"location":"development/contributing/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/pygnome.git\ncd pygnome\n</code></pre></li> <li>Set up a virtual environment:    <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre></li> <li>Install the package in development mode:    <pre><code>pip install -e .\n</code></pre></li> <li>Install development dependencies:    <pre><code>pip install -r requirements-dev.txt\n</code></pre></li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branching-strategy","title":"Branching Strategy","text":"<ul> <li><code>main</code>: The main development branch</li> <li><code>feature/*</code>: Feature branches</li> <li><code>bugfix/*</code>: Bug fix branches</li> <li><code>release/*</code>: Release branches</li> </ul>"},{"location":"development/contributing/#creating-a-new-feature-or-bug-fix","title":"Creating a New Feature or Bug Fix","text":"<ol> <li>Create a new branch from <code>main</code>:    <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b bugfix/issue-number\n</code></pre></li> <li>Make your changes</li> <li>Run tests to ensure your changes don't break existing functionality:    <pre><code>./scripts/tests.sh\n</code></pre></li> <li>Commit your changes:    <pre><code>git add .\ngit commit -m \"Your descriptive commit message\"\n</code></pre></li> <li>Push your branch to your fork:    <pre><code>git push origin feature/your-feature-name\n</code></pre></li> <li>Create a pull request on GitHub</li> </ol>"},{"location":"development/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"development/contributing/#python-code-style","title":"Python Code Style","text":"<ul> <li>Use type hints in function and method signatures</li> <li>Use the new way of defining types (e.g., <code>dict</code>, <code>list</code>, <code>| None</code>, <code>any</code>)</li> <li>Write short but informative docstrings</li> <li>Use <code>Path</code> from <code>pathlib</code> instead of <code>str</code> / <code>import os</code> for file operations</li> <li>Use Pydantic classes or dataclasses instead of <code>dict</code> structures</li> <li>Use <code>Enum</code> objects instead of hard-coded string values</li> <li>Remove unused imports</li> <li>Sort functions and methods alphabetically (except underscores)</li> <li>Keep files under 500 lines; refactor if they get too long</li> <li>Write classes (and enums) in their own files whenever possible</li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<ul> <li>Write unit tests for all new functionality</li> <li>Place test files in the <code>tests</code> directory</li> <li>Use Python's built-in <code>unittest</code> framework</li> <li>Run tests using the provided script:   <pre><code>./scripts/tests.sh\n</code></pre></li> </ul>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>Update documentation for any changes to the API</li> <li>Write clear and concise documentation</li> <li>Include examples where appropriate</li> <li>Use markdown for documentation files</li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your code follows the coding standards</li> <li>Update the documentation as necessary</li> <li>Add or update tests as necessary</li> <li>Ensure all tests pass</li> <li>Submit your pull request</li> <li>Address any feedback from reviewers</li> </ol>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<ol> <li>Update the version number in <code>pyproject.toml</code></li> <li>Update the changelog</li> <li>Create a new release branch: <code>release/vX.Y.Z</code></li> <li>Create a pull request to merge the release branch into <code>main</code></li> <li>Once the pull request is approved and merged, create a new release on GitHub</li> <li>Tag the release with the version number</li> <li>Publish the package to PyPI</li> </ol>"},{"location":"user-guide/advanced-usage/","title":"Advanced Usage","text":"<p>This guide covers advanced usage patterns and optimization techniques for PyGnome.</p>"},{"location":"user-guide/advanced-usage/#genomic-feature-stores","title":"Genomic Feature Stores","text":""},{"location":"user-guide/advanced-usage/#genomic-feature-store-selection","title":"Genomic Feature Store Selection","text":"<p>Genomic feature stores are one of the core solutions in PyGnome, providing specialized data structures for efficient storage, indexing, and querying of genomic features based on their genomic coordinates. They solve the fundamental bioinformatics challenge of quickly locating genomic elements within large genomes.</p> <p>PyGnome offers multiple feature store implementations with different performance characteristics:</p> Store Type Memory Usage Query Speed Best For <code>IntervalTreeStore</code> Medium Fast General purpose, balanced performance <code>BinnedGenomicStore</code> Medium Medium Large genomes, memory-constrained environments <code>BruteForceFeatureStore</code> Medium Slow Testing, very small datasets <code>MsiChromosomeStore</code> Very Low Fast Specialized for microsatellite sites <p>Choose the appropriate store type based on your specific use case:</p> <pre><code>from pygnome.feature_store.genomic_feature_store import GenomicFeatureStore, StoreType\n\n# For general use\ndefault_store = GenomicFeatureStore()  # Uses IntervalTreeStore\n\n# For memory-constrained environments\nbinned_store = GenomicFeatureStore(store_type=StoreType.BINNED, bin_size=100000)\n\n# For testing with small datasets\nbrute_force_store = GenomicFeatureStore(store_type=StoreType.BRUTE_FORCE)\n\n# For microsatellite sites\nmsi_store = GenomicFeatureStore(store_type=StoreType.MSI)\n</code></pre>"},{"location":"user-guide/advanced-usage/#memory-and-performance-optimization","title":"Memory and Performance Optimization","text":"<p>When working with large genomes, use these techniques to optimize performance:</p>"},{"location":"user-guide/advanced-usage/#1-use-the-context-manager-pattern","title":"1. Use the Context Manager Pattern","text":"<p>Always use the context manager pattern when adding features to ensure proper indexing:</p> <pre><code>with feature_store:\n    for feature in features:\n        feature_store.add(feature)\n</code></pre>"},{"location":"user-guide/advanced-usage/#2-save-and-load-feature-stores-to-avoid-rebuilding","title":"2. Save and Load Feature Stores to Avoid Rebuilding","text":"<p>Building genomic feature stores with large datasets can be time-consuming, especially when creating indexes for efficient querying. Once built, save them to disk to avoid rebuilding them in future sessions:</p> <pre><code># Building a store with millions of features can take time\nstore = GenomicFeatureStore()\nwith store:\n    # Adding features from a large genome...\n    for gene in genome.genes.values():\n        store.add(gene)\n        # Add transcripts, exons, etc.\n\n# Save the built store (trimming is done automatically)\nstore.save(Path(\"path/to/store.pkl\"))\n\n# In future sessions, quickly load the pre-built store\nloaded_store = GenomicFeatureStore.load(Path(\"path/to/store.pkl\"))\n# Ready to use immediately without rebuilding indexes\n</code></pre> <p>Note: The <code>save()</code> method automatically calls <code>trim()</code> to reduce memory usage before serialization, so you don't need to call it manually.</p>"},{"location":"user-guide/advanced-usage/#working-with-large-genomes","title":"Working with Large Genomes","text":"<p>When working with large genomes, consider these approaches:</p>"},{"location":"user-guide/advanced-usage/#chunked-processing","title":"Chunked Processing","text":"<p>Process large files in chunks to reduce memory usage:</p> <pre><code>from pathlib import Path\nfrom pygnome.parsers.fasta.fasta_parser import FastaParser\n\n# Process a large FASTA file in chunks\nparser = FastaParser(Path(\"path/to/large_genome.fa\"))\nfor record in parser:\n    # Process one sequence at a time\n    process_sequence(record.identifier, record.sequence)\n</code></pre>"},{"location":"user-guide/advanced-usage/#advanced-feature-store-usage","title":"Advanced Feature Store Usage","text":""},{"location":"user-guide/advanced-usage/#working-with-genomic-variants","title":"Working with Genomic Variants","text":""},{"location":"user-guide/advanced-usage/#reading-variants-from-vcf-files","title":"Reading Variants from VCF Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.vcf.vcf_reader import VcfReader\n\n# Open a VCF file\nwith VcfReader(Path(\"path/to/variants.vcf\")) as reader:\n    for vcf_record in reader:\n        # A single VCF record (i.e. vcf line) can have multiple variants\n        for variant in vcf_record:\n            print(f\"Variant: {variant}\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#annotating-variants-with-genomic-feature-stores","title":"Annotating Variants with Genomic Feature stores","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.vcf.vcf_reader import VcfReader\nfrom pygnome.feature_store.genomic_feature_store import GenomicFeatureStore\nfrom pygnome.parsers.genome_loader import GenomeLoader\n\n# Load the genome\nloader = GenomeLoader(genome_name=\"GRCh38\", species=\"Homo sapiens\")\ngenome = loader.load(\n    annotation_file=Path(\"path/to/annotations.gtf\"),\n    sequence_file=Path(\"path/to/genome.fa.gz\")\n)\n\n# Create a feature store with all genes\nstore = GenomicFeatureStore()\nwith store:\n    for gene in genome.genes.values():\n        store.add(gene)\n        for transcript in gene.transcripts:\n            store.add(transcript)\n            for exon in transcript.exons:\n                store.add(exon)\n\n# Open a VCF file\nwith VcfReader(Path(\"path/to/variants.vcf\")) as reader:\n    for record in reader:\n        # A single VCF record (i.e. vcf line) can have multiple variants\n        for variant in vcf_record:\n            # Get the variant position\n            chrom = variant.get_chrom()\n            pos = variant.get_pos()\n\n            # Find features at this position\n            features = store.get_by_position(chrom, pos)\n\n            # Show matches\n            for feature in features:\n                print(f\"Variant at {chrom}:{pos} overlaps {feature.id} ({feature.__class__.__name__})\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#custom-feature-filtering","title":"Custom Feature Filtering","text":"<p>Combine feature store queries with custom filtering:</p> <pre><code>from pygnome.feature_store.genomic_feature_store import GenomicFeatureStore\nfrom pygnome.genomics.gene import Gene\n\n# Create and populate a feature store\nstore = GenomicFeatureStore()\n# ... add features ...\n\n# Get all features in a range\nfeatures = store.get_by_interval(\"chr1\", 1000000, 2000000)\n\n# Filter for specific feature types\ngenes = [f for f in features if isinstance(f, Gene)]\n\n# Filter by additional criteria\nprotein_coding_genes = [g for g in genes if g.biotype == \"protein_coding\"]\n</code></pre>"},{"location":"user-guide/advanced-usage/#custom-genomic-feature-types","title":"Custom Genomic Feature Types","text":"<p>You can create custom genomic feature types by extending the <code>GenomicFeature</code> class:</p> <pre><code>from dataclasses import dataclass\nfrom pygnome.genomics.genomic_feature import GenomicFeature\nfrom pygnome.genomics.strand import Strand\n\n@dataclass\nclass EnhancerRegion(GenomicFeature):\n    \"\"\"A genomic enhancer region.\"\"\"\n    target_genes: list[str] = None\n    activity_score: float = 0.0\n\n    def __post_init__(self):\n        super().__post_init__()\n        if self.target_genes is None:\n            self.target_genes = []\n\n    def is_active(self, threshold: float = 0.5) -&gt; bool:\n        \"\"\"Check if the enhancer is active based on its activity score.\"\"\"\n        return self.activity_score &gt;= threshold\n\n# Create an enhancer\nenhancer = EnhancerRegion(\n    id=\"ENH001\",\n    chrom=\"chr1\",\n    start=1000000,\n    end=1001000,\n    strand=Strand.POSITIVE,\n    target_genes=[\"GENE001\", \"GENE002\"],\n    activity_score=0.75\n)\n\n# Add to a feature store\nstore = GenomicFeatureStore()\nwith store:\n    store.add(enhancer)\n\n# Query enhancers\nenhancers = [f for f in store.get_by_interval(\"chr1\", 900000, 1100000) \n             if isinstance(f, EnhancerRegion)]\nactive_enhancers = [e for e in enhancers if e.is_active()]\n</code></pre>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the basic usage of PyGnome's core components with practical examples.</p>"},{"location":"user-guide/basic-usage/#working-with-genomic-models","title":"Working with Genomic Models","text":"<p>PyGnome provides a comprehensive object model for genomic features.</p>"},{"location":"user-guide/basic-usage/#creating-a-genome","title":"Creating a Genome","text":"<pre><code>from pygnome.genomics.genome import Genome\nfrom pygnome.genomics.chromosome import Chromosome\nfrom pygnome.genomics.gene import Gene\nfrom pygnome.genomics.transcript import Transcript\nfrom pygnome.genomics.exon import Exon\nfrom pygnome.genomics.strand import Strand\n\n# Create a genome\ngenome = Genome(name=\"MyGenome\", species=\"Example species\")\n\n# Create a chromosome\nchromosome = Chromosome(name=\"chr1\", length=248956422)\n\n# Add the chromosome to the genome\ngenome.add_chromosome(chromosome)\n\n# Create a gene\ngene = Gene(\n    id=\"GENE001\",\n    name=\"Example Gene\",\n    chrom=\"chr1\",\n    start=1000,\n    end=5000,\n    strand=Strand.POSITIVE\n)\n\n# Create a transcript\ntranscript = Transcript(\n    id=\"TRANSCRIPT001\",\n    gene_id=\"GENE001\",\n    chrom=\"chr1\",\n    start=1000,\n    end=5000,\n    strand=Strand.POSITIVE\n)\n\n# Create exons\nexon1 = Exon(\n    id=\"EXON001\",\n    chrom=\"chr1\",\n    start=1000,\n    end=2000,\n    strand=Strand.POSITIVE\n)\n\nexon2 = Exon(\n    id=\"EXON002\",\n    chrom=\"chr1\",\n    start=3000,\n    end=5000,\n    strand=Strand.POSITIVE\n)\n\n# Add exons to transcript\ntranscript.exons = [exon1, exon2]\n\n# Add transcript to gene\ngene.add_transcript(transcript)\n\n# Add gene to chromosome\nchromosome.add_gene(gene)\n\n# Now the gene is also accessible from the genome\nprint(genome.genes[\"GENE001\"])\n</code></pre>"},{"location":"user-guide/basic-usage/#parsing-genomic-files","title":"Parsing Genomic Files","text":"<p>PyGnome provides parsers for common genomic file formats.</p>"},{"location":"user-guide/basic-usage/#parsing-fasta-files","title":"Parsing FASTA Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.fasta.fasta_parser import FastaParser\n\n# Parse a FASTA file\nparser = FastaParser(Path(\"path/to/sequences.fa\"))\nrecords = parser.load()\n\n# Access sequences\nfor record in records:\n    print(f\"Sequence: {record.identifier}\")\n    print(f\"Length: {len(record.sequence)}\")\n\n    # Convert to string if needed\n    seq_str = str(record.sequence)\n    print(f\"First 10 bases: {seq_str[:10]}\")\n\n# Load as dictionary for quick access by identifier\nsequences = FastaParser(Path(\"path/to/sequences.fa\")).load_as_dict()\nmy_seq = sequences[\"chr1\"].sequence\n</code></pre>"},{"location":"user-guide/basic-usage/#parsing-gffgtf-files","title":"Parsing GFF/GTF Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.gff.gff3_parser import Gff3Parser\nfrom pygnome.parsers.gff.gtf_parser import GtfParser\n\n# Parse a GFF3 file\ngff_parser = Gff3Parser(Path(\"path/to/annotations.gff3\"))\nfor record in gff_parser:\n    print(f\"{record.type}: {record.chrom}:{record.start}-{record.end}\")\n    print(f\"Attributes: {record.attributes}\")\n\n# Parse a GTF file\ngtf_parser = GtfParser(Path(\"path/to/annotations.gtf\"))\nfor record in gtf_parser:\n    if record.type == \"gene\":\n        gene_id = record.attributes.get(\"gene_id\")\n        gene_name = record.attributes.get(\"gene_name\")\n        print(f\"Gene: {gene_id} ({gene_name}) - {record.chrom}:{record.start}-{record.end}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#parsing-vcf-files","title":"Parsing VCF Files","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.vcf.vcf_reader import VcfReader\n\n# Open a VCF file\nwith VcfReader(Path(\"path/to/variants.vcf\")) as reader:\n    # Get sample names\n    samples = reader.get_samples()\n    print(f\"Samples: {samples}\")\n\n    # Iterate through records\n    for record in reader:\n        print(f\"Record: {record.get_chrom()}:{record.get_pos()} {record.get_ref()}&gt;{','.join(record.get_alt())}\")\n\n        # Create variant objects from the record\n        for variant in record:  # Uses VariantFactory internally\n            print(f\"Variant: {variant}\")\n\n        # Access genotypes\n        genotypes = record.get_genotypes()\n        for i, genotype in enumerate(genotypes):\n            print(f\"  {samples[i]}: {genotype}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-dnarna-sequences","title":"Working with DNA/RNA Sequences","text":"<p>PyGnome provides memory-efficient representations of DNA and RNA sequences.</p>"},{"location":"user-guide/basic-usage/#creating-and-manipulating-dna-sequences","title":"Creating and Manipulating DNA Sequences","text":"<pre><code>from pygnome.sequences.dna_string import DnaString\nfrom pygnome.sequences.rna_string import RnaString\n\n# Create a DNA sequence\ndna = DnaString(\"ATGCATGCATGC\")\nprint(f\"Length: {len(dna)}\")\n\n# Get a subsequence\nsubseq = dna[3:9]  # Returns a new DnaString\nprint(f\"Subsequence: {subseq}\")\n\n# Complement and reverse complement\ncomp = dna.complement()\nrev_comp = dna.reverse_complement()\nprint(f\"Complement: {comp}\")\nprint(f\"Reverse complement: {rev_comp}\")\n\n# Transcribe DNA to RNA\nrna = dna.transcribe()  # Returns an RnaString\nprint(f\"RNA: {rna}\")\n\n# Create an RNA sequence\nrna = RnaString(\"AUGCAUGCAUGC\")\n\n# Translate RNA to protein\nprotein = rna.translate()\nprint(f\"Protein: {protein}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-multiple-sequences","title":"Working with Multiple Sequences","text":"<pre><code>from pygnome.sequences.dna_string_array import DnaStringArray\n\n# Create a DNA string array\narray = DnaStringArray()\n\n# Add sequences\nidx1 = array.add(\"ATGCATGC\")\nidx2 = array.add(\"GCTAGCTA\")\n\n# Add multiple sequences at once\nindices = array.add_multiple([\"AAAAAA\", \"CCCCCC\", \"GGGGGG\"])\n\n# Access sequences\nseq1 = array[idx1]\nprint(f\"Sequence 1: {seq1}\")\n\n# Get subsequences\nsubseq = array.get_subsequence(idx2, 2, 4)\nprint(f\"Subsequence: {subseq}\")\n\n# Get statistics\ncount, total_nt, bits_per_nt = array.get_stats()\nprint(f\"Sequences: {count}, Total nucleotides: {total_nt}, Bits per nucleotide: {bits_per_nt:.2f}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#using-feature-stores","title":"Using Feature Stores","text":"<p>Feature stores provide efficient storage and retrieval of genomic features.</p>"},{"location":"user-guide/basic-usage/#creating-and-using-a-feature-store","title":"Creating and Using a Feature Store","text":"<pre><code>from pygnome.feature_store.genomic_feature_store import GenomicFeatureStore, StoreType\nfrom pygnome.genomics.gene import Gene\nfrom pygnome.genomics.strand import Strand\nfrom pathlib import Path\n\n# Create a feature store using interval trees (default)\nstore = GenomicFeatureStore()\n\n# Or choose a different implementation\nbinned_store = GenomicFeatureStore(store_type=StoreType.BINNED, bin_size=100000)\nbrute_force_store = GenomicFeatureStore(store_type=StoreType.BRUTE_FORCE)\n\n# Create some features\ngene1 = Gene(id=\"GENE001\", chrom=\"chr1\", start=1000, end=5000, strand=Strand.POSITIVE)\ngene2 = Gene(id=\"GENE002\", chrom=\"chr1\", start=7000, end=9000, strand=Strand.NEGATIVE)\ngene3 = Gene(id=\"GENE003\", chrom=\"chr2\", start=2000, end=6000, strand=Strand.POSITIVE)\n\n# Add features to the store\nwith store:  # Use context manager to ensure proper indexing\n    store.add(gene1)\n    store.add(gene2)\n    store.add(gene3)\n\n# Query features\nfeatures_at_position = store.get_by_position(\"chr1\", 1500)\nprint(f\"Features at position chr1:1500: {features_at_position}\")\n\nfeatures_in_range = store.get_by_interval(\"chr1\", 4000, 8000)\nprint(f\"Features in range chr1:4000-8000: {features_in_range}\")\n\nnearest_feature = store.get_nearest(\"chr1\", 6000)\nprint(f\"Nearest feature to chr1:6000: {nearest_feature}\")\n\n# Save and load the store\nstore.save(Path(\"path/to/store.pkl\"))\nloaded_store = GenomicFeatureStore.load(Path(\"path/to/store.pkl\"))\n</code></pre>"},{"location":"user-guide/basic-usage/#loading-a-complete-genome","title":"Loading a Complete Genome","text":"<pre><code>from pathlib import Path\nfrom pygnome.parsers.genome_loader import GenomeLoader\n\n# Create a genome loader\nloader = GenomeLoader(\n    genome_name=\"GRCh38\",\n    species=\"Homo sapiens\",\n    verbose=True  # Print progress information\n)\n\n# Load genome structure and sequence\ngenome = loader.load(\n    annotation_file=Path(\"path/to/annotations.gtf\"),\n    sequence_file=Path(\"path/to/genome.fa.gz\")\n)\n\n# Access genome components\nprint(f\"Genome: {genome.name} ({genome.species})\")\nprint(f\"Chromosomes: {len(genome.chromosomes)}\")\nprint(f\"Genes: {len(genome.genes)}\")\n\n# Get a specific chromosome\nchr1 = genome.chromosomes.get(\"chr1\")\nif chr1:\n    print(f\"Chromosome: {chr1.name}, Length: {chr1.length}\")\n    print(f\"Genes on chr1: {len(chr1.genes)}\")\n\n# Get a specific gene\ntp53 = genome.genes.get(\"TP53\")\nif tp53:\n    print(f\"TP53: {tp53.chrom}:{tp53.start}-{tp53.end} ({tp53.strand})\")\n\n    # Get gene transcripts\n    for transcript in tp53.transcripts:\n        print(f\"Transcript {transcript.id}: Exons: {len(transcript.exons)}\")\n</code></pre>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>Installing PyGnome is simple:</p> <pre><code>pip install pygnome\n</code></pre> <p>This will install PyGnome and all its required dependencies.</p>"},{"location":"user-guide/installation/#requirements","title":"Requirements","text":"<p>PyGnome requires:</p> <ul> <li>Python 3.9 or higher</li> <li>NumPy for efficient array operations</li> <li>Pathlib for file path handling</li> </ul> <p>These dependencies will be automatically installed when you use pip.</p>"},{"location":"user-guide/installation/#upgrading","title":"Upgrading","text":"<p>To upgrade PyGnome to the latest version:</p> <pre><code>pip install --upgrade pygnome\n</code></pre>"},{"location":"user-guide/installation/#for-contributors","title":"For Contributors","text":"<p>If you want to contribute to PyGnome development, you can install from the source code:</p> <pre><code># Clone the repository\ngit clone https://github.com/pcingola/pygnome.git\ncd pygnome\n\n# Install in development mode\npip install -e .\n</code></pre> <p>Installing in development mode (<code>-e</code>) allows you to modify the code and have the changes immediately available without reinstalling.</p>"}]}